/*	nodescape.c

	NodeScape is a generic tool for monitoring the status of
	a multitude of parameters for a multitude of objects...
	nominally, nodes of a cluster supercomputer.

	Status information is collected via straightforward UDP
	packets sent to nodescape. Each packet has a very simple
	format which can be generated by the epacsedon utility,
	so that any status daemon can easily create UDP packets.
	The communication is deliberately not closed loop; the
	nodes simply throw packets at the nodescape server. The
	unreliable delivery and packet order are dealt with by
	incorporating a timestamp and ignoring packets marked
	as older than the youngest one processed for that node.

	The nodescape server uses key and base image files to
	generate a separate display image for each status
	attribute. The files are:

	* The key image is expected to be a P5-format (binary
	  monochrome) image in which node 0 is black, node 1 is a
	  gray level of 1, etc. Background pixels should be white.

	* The base image is expected to be a P6-format (binary
	  red-green-blue) image with arbitrary content. The key
	  is used to determine where colors are overlayed in the
	  copy of the base image created for each attribute, but
	  the base image itself is never modified.

	* The display image for each attribute will be a file in
	  P6 format that is named after the attribute it displays.
	  This naming allows additional attributes to be added by
	  simply sending UDP messages with new attribute names.
	  The attribute files are created as copies of the base
	  image that are kept mapped into the nodescape server
	  and incrementally updated as each UDP packet comes in.
	  Any other program(s) can display the current status by
	  simply displaying the appropriate attribute image.
	  The color of a node is set to a shade of red to blue
	  depending on the relative value of that attribute...
	  unless no packets have been reported for too long, in
	  which case the color will change to magenta.

	In the SenScape tradition, the displays use color to
	represent age of the data. Normally, SenScape advocates
	use of color desaturation to show age and unreliability
	of the data, but that doesn't work as well with this.
	Instead, an age-increasing fraction of magenta pixels
	are used. This gives a nice textural feel to it....

	April 2011 by Hank Dietz
*/

#include "nodescape.h"

#define	SELTIMEOUT	1	/* select timeout for age updates */
#define	BEGINFADE	60	/* when to begin fading color, in seconds */
#define	FADETIME	(15*60)	/* how long before it is magenta, in seconds */
#define	MAXFADE		(0.8)	/* don't fade completely, so last value is visible */

extern unsigned char *
map_P56(register char *filename,
int *xdim,
int *ydim,
int *bpp,
int rw);

extern int
write_P6(register char *filename,
register char *comment,
register int xdim,
register int ydim,
register int maxval,
register unsigned char *data);

int r, g, b;

int port = MYPORTNO;		/* My unique magic port number */

#define	MAXPROP	16
#define	MAXNODE	255	/* 8-bit key image for now... */

typedef	struct {
	double		min, max;		/* value bounds */
	double		lastup;			/* when was display last updated? */
	unsigned char	*disp;			/* display buffer (mapped PPM) */
	char		name[PROPLEN];		/* Name of property */
	stat_t		status[MAXNODE];	/* really variable size */
} prop_t;

prop_t	prop[MAXPROP];

#include <sys/select.h>

inline void
t2rgb(register float mint,
register float t,
register float maxt)
{
	/* Special case for no data */
	if (maxt <= mint) {
		t = 0.5;
	} else {
		if (t < mint) t = mint;
		if (t > maxt) t = maxt;
		t -= mint;
		t /= (maxt - mint);
	}

	/* Only use colors to blue, red is hot */
	t = 0.8 - (t * 0.8);

	switch ((int) (t * 5)) {
	case 0:
		r = 255;
		g = 5 * 255 * t;
		b = 0;
		break;
	case 1:
		r = 5 * 255 * (0.4 - t);
		g = 255;
		b = 0;
		break;
	case 2:
		r = 0;
		g = 255;
		b = 5 * 255 * (t - 0.4);
		break;
	case 3:
		r = 0;
		g = 5 * 255 * (0.8 - t);
		b = 255;
		break;
	default:
		r = 5 * 255 * (t - 0.8);
		g = 0;
		b = 255;
	}
}

static inline unsigned char
overlay(register unsigned char i,
register unsigned char m)
{
	register float e = (i / 255.0) * (i + ((2.0 * m) / 255.0) * (255.0 - i));
	if (e < 0) e = 0; else if (e > 255) e = 255;
	return((unsigned char) (e + 0.5));
}

void
tint(register int who,
register unsigned char *key,
register unsigned char *base,
register unsigned char *disp,
register int pixels)
{
	do {
		if (*(key++) == who) {
			disp[0] = overlay(base[0], r);
			disp[1] = overlay(base[1], g);
			disp[2] = overlay(base[2], b);
		}
		base += 3;
		disp += 3;
	} while (--pixels > 0);
}

void
uptint(register int propno,
register unsigned char *key,
register unsigned char *base,
register int pixels)
{
	register unsigned char *disp = prop[propno].disp;
	register double now = dtime();
	register double age;
	register int lastn = 255;

	/* Don't update when nothing could look different */
	if (now < (prop[propno].lastup + (FADETIME / (512.0 * MAXFADE)))) return;
	prop[propno].lastup = now;

	do {
		if (*key < 255) {
			/* Determine color tint for this pixel */
			if (*key != lastn) {
				/* Only recompute if from a different node */
				lastn = *key;
				t2rgb(prop[propno].min,
				      prop[propno].status[lastn].value,
				      prop[propno].max);
			}

			/* Is entry old enough to age? */
			age = prop[propno].status[lastn].when;
			if (age == 0) {
				/* There is no previous value, force magenta */
				disp[0] = overlay(base[0], 255);
				disp[1] = overlay(base[1], 0);
				disp[2] = overlay(base[2], 255);
				goto colored;
			}
			age = now - age;
			age = (age - BEGINFADE) / FADETIME;
			if (age > 1.0) age = 1.0;
			age *= MAXFADE;
			if (age > ((rand() % 1000000) / 1000000.0)) {
				/* Force magenta tint */
				disp[0] = overlay(base[0], 255);
				disp[1] = overlay(base[1], 0);
				disp[2] = overlay(base[2], 255);
			} else {
				/* Use the normal tint */
				disp[0] = overlay(base[0], r);
				disp[1] = overlay(base[1], g);
				disp[2] = overlay(base[2], b);
			}
		}
colored:
		++key;
		base += 3;
		disp += 3;
	} while (--pixels > 0);
}


#include <fcntl.h>
#include <sys/mman.h>

unsigned char *
map_P56(register char *filename,
int *xdim,
int *ydim,
int *bpp,
int rw)
{
	/* The following is a fast and sloppy way to
	   read a color raw PPM (P6) image file
	*/
	register int fd;
	register int fsize;
	register unsigned char *map;
	register unsigned char *p;
	int maxval;

	/* First, open the file... */
	if ((fd = open(filename, (rw ? O_RDWR : O_RDONLY))) < 0) {
		return((unsigned char *) 0);
	}

	/* Read size and map the whole file... */
	fsize = lseek(fd, ((off_t) 0), SEEK_END);
	map = ((unsigned char *)
	       mmap(0,		/* Put it anywhere */
		    fsize,	/* Map the whole file */
		    (rw ? (PROT_READ | PROT_WRITE) : PROT_READ),
		    MAP_SHARED,	/* Not just for me */
		    fd,		/* The file */
		    0));	/* Right from the start */
	if (map == ((unsigned char *) -1)) {
		close(fd);
		return((unsigned char *) 0);
	}

	/* File should now be mapped; read magic value */
	p = map;
	if (*(p++) != 'P') goto ppm_exit;
	switch (*(p++)) {
	case '5':
		*bpp = 1;
		break;
	case '6':
		*bpp = 3;
		break;
	default:
		goto ppm_exit;
	}

#define	Eat_Space \
	while ((*p == ' ') || \
	       (*p == '\t') || \
	       (*p == '\n') || \
	       (*p == '\r') || \
	       (*p == '#')) { \
		if (*p == '#') while (*(++p) != '\n') ; \
		++p; \
	}

	Eat_Space;		/* Eat white space and comments */

#define	Get_Number(n) \
	{ \
		register int charval = *p; \
 \
		if ((charval < '0') || (charval > '9')) goto ppm_exit; \
 \
		n = (charval - '0'); \
		charval = *(++p); \
		while ((charval >= '0') && (charval <= '9')) { \
			n *= 10; \
			n += (charval - '0'); \
			charval = *(++p); \
		} \
	}

	Get_Number(*xdim);	/* Get image width */

	Eat_Space;		/* Eat white space and comments */
	Get_Number(*ydim);	/* Get image width */

	Eat_Space;		/* Eat white space and comments */
	Get_Number(maxval);	/* Get image max value */

	/* 1 or 2 bytes per color channel? */
	if (maxval > 255) {
		*bpp *= 2;
	}
	if ((*p != ' ') &&
	    (*p != '\t') &&
	    (*p != '\n') &&
	    (*p != '\r')) goto ppm_exit;

	/* Here we are... next byte begins the 24-bit data */
	return(p + 1);

	/* Notice that we never clean-up after this:

	   close(fd);
	   munmap(map, fsize);

	   However, this is relatively harmless;
	   they will go away when this process dies.
	*/

ppm_exit:
	close(fd);
	munmap(map, fsize);
	return((unsigned char *) 0);
}

#undef	Eat_Space
#undef	Get_Number


int
write_P6(register char *filename,
register char *comment,
register int xdim,
register int ydim,
register int maxval,
register unsigned char *data)
{
	register int fd;
	register int len;
	char buf[512];

	/* First, open the file... */
	fd = open(filename, (O_WRONLY | O_CREAT), 0644);
	if (fd < 0) {
		return(1);
	}

	/* Then write the header... */
	sprintf(&(buf[0]),
		"P6\n#%s\n%d %d\n%d\n",
		(comment ?
		 comment :
		 filename),
		xdim,
		ydim,
		maxval);
	len = strlen(&(buf[0]));
	if (write(fd, &(buf[0]), len) != len) {
		close(fd);
		return(2);
	}

	/* Then write the data... */
	len = (xdim * ydim * 3);
	if (write(fd, data, len) != len) {
		close(fd);
		return(3);
	}

	/* All looks good */
	close(fd);
	return(0);
}


main(register int argc,
register char **argv)
{
	register unsigned char *key;
	register unsigned char *base;
	register unsigned char *disp;
	int kxdim, kydim, kbpp;
	int bxdim, bydim, bbpp;
        int sock;
        int addr_len, bytes_read;
        char recv_data[1024];
        struct sockaddr_in server_addr, client_addr;

	/* Process command line... */
	if (argc != 3) {
		fprintf(stderr,
			"Usage: %s [key].pgm [base].ppm\n",
			argv[0]);
		exit(1);
	}

	/* Map the key file */
	key = map_P56(argv[1],
		      &kxdim,
		      &kydim,
		      &kbpp,
		      0);
	if (key == 0) {
		fprintf(stderr,
			"%s: could not read %s\n",
			argv[0],
			argv[1]);
		exit(2);
	}

	/* Map the base image file */
	base = map_P56(argv[2],
		       &bxdim,
		       &bydim,
		       &bbpp,
		       0);
	if (base == 0) {
		fprintf(stderr,
			"%s: could not read %s\n",
			argv[0],
			argv[2]);
		exit(3);
	}

	/* Check that dimensions match */
	if ((kxdim != bxdim) ||
	    (kydim != bydim)) {
		fprintf(stderr,
			"%s: key %s and base %s are not the same size\n",
			argv[0],
			argv[1],
			argv[2]);
		exit(4);
	}

	/* Clear properties */
	prop[0].name[0] = 0;

        if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
		perror("Socket");
		exit(1);
	}

        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(MYPORTNO);
        server_addr.sin_addr.s_addr = INADDR_ANY;
        bzero(&(server_addr.sin_zero),8);


        if (bind(sock,
		 (struct sockaddr *)&server_addr,
		 sizeof(struct sockaddr)) == -1) {
		perror("Bind");
		exit(1);
	}

        addr_len = sizeof(struct sockaddr);

	printf("Waiting for status messages on port %d....\n", MYPORTNO);

	/* Accept UDP messages forever... */
	for (;;) {
		register int fd;
		int i, j;
		mesg_t buf;
		char tmp[1024];
		register int sval = 0;
		register int bytes = 0;

		do {
			fd_set rd, wr, er;
			struct timeval to;

			to.tv_sec = SELTIMEOUT;
			to.tv_usec = 0;
			FD_ZERO(&rd);
			FD_ZERO(&wr);
			FD_ZERO(&er);
			FD_SET(sock, &rd);
			sval = select(sock+1, &rd, &wr, &er, &to);
			if (sval == 0) {
				/* Timed out... try age update */
				for (j=0; prop[j].name[0]; ++j) {
					uptint(j, key, base, kxdim*kydim);
				}
			}
		} while ((sval == 0) || (sval == -1));

		bytes = recvfrom(sock,
				 &buf,
				 sizeof(buf),
				 0,
				 (struct sockaddr *)&client_addr, &addr_len);
		if (bytes < 1) {
			fprintf(stderr,
				"Unable to recvfrom (%s)\n",
				strerror(errno));
			exit(1);
		} else {
			/* Print message */
			printf("From node %d at time %1.2f: %s=%1.2f\n",
			       buf.node,
			       buf.status.when,
			       &(buf.name[0]),
			       buf.status.value);

			/* Check that node is valid */
			if (buf.node > ((unsigned int) MAXNODE)) {
				printf("Node %u is out of range\n", buf.node);
			} else {
				/* Find appropriate entry and update it */
				for (i=0; prop[i].name[0]; ++i) {
					if (strcmp(&(prop[i].name[0]), &(buf.name[0])) == 0) {
						/* Found this attribute...
						   update min, max values seen
						*/
						if (prop[i].min > buf.status.value) {
							prop[i].min = buf.status.value;
							uptint(i, key, base, kxdim*kydim);
						} else if (prop[i].max < buf.status.value) {
							prop[i].max = buf.status.value;
							uptint(i, key, base, kxdim*kydim);
						}

						if (prop[i].status[buf.node].when > buf.status.when) {
							/* Old UDP packet...
							   ignored, except in that it could have
							   updated min, max values for later
							*/
							printf("Old packet ignored\n");
						} else {
							/* Update log & tint the display image */
							prop[i].status[buf.node] = buf.status;
#ifdef	NOTNOW
							t2rgb(prop[i].min, buf.status.value, prop[i].max);
							tint(buf.node, key, base, prop[i].disp, kxdim*kydim);
#endif
							uptint(i, key, base, kxdim*kydim);
						}
						goto entered;
					}
				}

				/* Didn't find it... a new attribute */
				printf("Creating new attribute %s...\n", &(buf.name[0]));
				strcpy(&(prop[i].name[0]), &(buf.name[0]));
				prop[i+1].name[0] = 0;
				for (j=0; j<MAXNODE; ++j) {
					prop[i].status[j].when = 0;
				}
				prop[i].status[buf.node] = buf.status;
				prop[i].lastup = 0;

				/* Write a copy of the base image */
				sprintf(&(tmp[0]), "%s.ppm", &(prop[i].name[0]));
				if (write_P6(&(tmp[0]),
					     "NodeScape output",
					     bxdim,
					     bydim,
					     255,
					     base)) {
					fprintf(stderr,
						"%s: could not write %s\n",
						argv[0],
						&(tmp[0]));
					exit(5);
				}

				/* Map the display image file */
				prop[i].disp = map_P56(&(tmp[0]),
						       &bxdim,
						       &bydim,
						       &bbpp,
						       1);
				if (prop[i].disp == 0) {
					fprintf(stderr,
						"%s: could not map %s\n",
						argv[0],
						&(tmp[0]));
					exit(6);
				}

				prop[i].status[buf.node] = buf.status;
				prop[i].min = (prop[i].max = buf.status.value);
				t2rgb(prop[i].min, buf.status.value, prop[i].max);
				tint(buf.node, key, base, prop[i].disp, kxdim*kydim);

entered:			;
			}
		}
	}

	/* All's well, let's end well */
	exit(0);
}
